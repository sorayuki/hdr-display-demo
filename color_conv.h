#pragma once

#include <math.h>

// return vec(4) * mat(4x4)
void MulMatrix(float vec[4], float mat[][4]) {
    float r[4];
    for (int i = 0; i < 4; ++i) {
        r[i] = vec[0] * mat[i][0] + vec[1] * mat[i][1] + vec[2] * mat[i][2] + vec[3] * mat[i][3];
    }
    for (int i = 0; i < 4; ++i) {
        vec[i] = r[i];
    }
}

// mat: 601, 709, 2020
// range: 0=full, 1=limited
float (*getYuv2RgbMat(int mat, int range))[4] {
    static float matrix[3][2][4][4] = {
        //BT.601, Full
        1.000000f, 0.000000f, 1.402000f, -0.701000f,
        1.000000f, -0.344136f, -0.714136f, 0.529136f,
        1.000000f, 1.772000f, 0.000000f, -0.886000f,
        0.000000f, 0.000000f, 0.000000f, 1.000000f,
        //BT.601, Limited
        1.164384f, 0.000000f, 1.596027f, -0.871073f,
        1.164384f, -0.391762f, -0.812968f, 0.529306f,
        1.164384f, 2.017232f, 0.000000f, -1.081675f,
        0.000000f, 0.000000f, 0.000000f, 1.000000f,
        //BT.709, Full
        1.000000f, 0.000000f, 1.574800f, -0.787400f,
        1.000000f, -0.187324f, -0.468124f, 0.327724f,
        1.000000f, 1.855600f, 0.000000f, -0.927800f,
        0.000000f, 0.000000f, 0.000000f, 1.000000f,
        //BT.709, Limited
        1.164384f, 0.000000f, 1.792741f, -0.969430f,
        1.164384f, -0.213249f, -0.532909f, 0.300020f,
        1.164384f, 2.112402f, -0.000000f, -1.129260f,
        0.000000f, 0.000000f, 0.000000f, 1.000000f,
        //BT.2020, Full
        1.000000f, -0.000000f, 1.474600f, -0.737300f,
        1.000000f, -0.164553f, -0.571353f, 0.367953f,
        1.000000f, 1.881400f, 0.000000f, -0.940700f,
        0.000000f, 0.000000f, 0.000000f, 1.000000f,
        //BT.2020, Limited
        1.164384f, 0.000000f, 1.678674f, -0.912396f,
        1.164384f, -0.187326f, -0.650424f, 0.345816f,
        1.164384f, 2.141772f, 0.000000f, -1.143946f,
        0.000000f, 0.000000f, 0.000000f, 1.000000f,
    };
    return matrix[mat][range];
}


float hlg_to_linear_c(float u)
{
    float ln2_i = 1. / log(2.);
    float m = ln2_i / 0.17883277;
    float a = -ln2_i * 0.55991073 / 0.17883277;
    return (u <= 0.5) ? ((u * u) / 3.) : ((exp2(u * m + a) + 0.28466892) / 12.);
}

void hlg_to_linear(float v[4], float exponent)
{
    // OETF-1
    for(int i = 0; i < 3; ++i) {
        v[i] = hlg_to_linear_c(v[i]);
    }

    // OOTF
    float Ys = v[0] * 0.2627f + v[1] * 0.678f + v[2] * 0.0593f;
    for(int i = 0; i < 3; ++i) {
        v[i] *= pow(Ys, exponent - 1.);
    }
}

void from_hlg(float p[4], float Lw) {
    float y = 1.2 + (Lw > 1000. ? (0.42 * log10(Lw / 1000.)) : 0);
    hlg_to_linear(p, y);
    for(int i = 0; i < 3; ++i) {
        p[i] = p[i] * Lw / 80.f;
    }
}

void rgb_2020_to_709(float p[4]) {
    float r = p[0] * 1.6604910021084345    + p[1] * -0.58764113878854951 + p[2] * -0.072849863319884883;
    float g = p[0] * -0.12455047452159074  + p[1] * 1.1328998971259603   + p[2] * -0.0083494226043694768;
    float b = p[0] * -0.018150763354905303 + p[1] * -0.10057889800800739 + p[2] * 1.1187296613629127;
    p[0] = r;
    p[1] = g;
    p[2] = b;
}
